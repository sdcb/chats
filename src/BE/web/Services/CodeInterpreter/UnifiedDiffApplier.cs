namespace Chats.BE.Services.CodeInterpreter;

internal static class UnifiedDiffApplier
{
    internal static string Apply(string originalText, string unifiedDiff)
    {
        // Minimal unified diff applier supporting @@ hunks with + / - /  context lines.
        // Designed for deterministic patches generated by LLM.
        if (unifiedDiff == null) throw new ArgumentNullException(nameof(unifiedDiff));

        string[] originalLines = SplitLinesPreserveNoNewline(originalText);
        List<string> output = new();

        string[] diffLines = unifiedDiff.Replace("\r\n", "\n").Split('\n');

        int origIndex = 0;
        int i = 0;

        while (i < diffLines.Length)
        {
            string line = diffLines[i];

            if (line.StartsWith("--- ", StringComparison.Ordinal) || line.StartsWith("+++ ", StringComparison.Ordinal))
            {
                i++;
                continue;
            }

            if (!line.StartsWith("@@", StringComparison.Ordinal))
            {
                i++;
                continue;
            }

            (int startOld, int countOld) = ParseHunkHeader(line);
            int targetOrigIndex = Math.Max(0, startOld - 1);

            // Copy unchanged lines before this hunk
            while (origIndex < targetOrigIndex && origIndex < originalLines.Length)
            {
                output.Add(originalLines[origIndex]);
                origIndex++;
            }

            i++; // move to hunk body

            while (i < diffLines.Length)
            {
                string hunkLine = diffLines[i];
                if (hunkLine.StartsWith("@@", StringComparison.Ordinal))
                {
                    break;
                }
                if (hunkLine.StartsWith("--- ", StringComparison.Ordinal) || hunkLine.StartsWith("+++ ", StringComparison.Ordinal))
                {
                    i++;
                    continue;
                }
                if (hunkLine.Length == 0)
                {
                    // empty line counts as context line with ' ' prefix in proper diffs.
                    // If it's truly empty due to splitting, treat as context match of empty.
                }

                char prefix = hunkLine.Length > 0 ? hunkLine[0] : ' ';
                string content = hunkLine.Length > 0 ? hunkLine[1..] : string.Empty;

                switch (prefix)
                {
                    case ' ':
                        EnsureLineEquals(originalLines, origIndex, content);
                        output.Add(content);
                        origIndex++;
                        break;
                    case '-':
                        EnsureLineEquals(originalLines, origIndex, content);
                        origIndex++;
                        break;
                    case '+':
                        output.Add(content);
                        break;
                    case '\\':
                        // "\\ No newline at end of file" - ignore
                        break;
                    default:
                        // Unknown line, treat as context
                        EnsureLineEquals(originalLines, origIndex, hunkLine);
                        output.Add(hunkLine);
                        origIndex++;
                        break;
                }

                i++;
            }
        }

        // Copy remaining original lines
        while (origIndex < originalLines.Length)
        {
            output.Add(originalLines[origIndex]);
            origIndex++;
        }

        return string.Join("\n", output);
    }

    private static (int startOld, int countOld) ParseHunkHeader(string header)
    {
        // @@ -start,count +start,count @@
        int minus = header.IndexOf('-', StringComparison.Ordinal);
        int plus = header.IndexOf('+', StringComparison.Ordinal);
        if (minus < 0 || plus < 0)
        {
            throw new InvalidOperationException($"Invalid hunk header: {header}");
        }

        int commaOrSpace = header.IndexOf(',', minus);
        int spaceAfterOld = header.IndexOf(' ', minus);
        int endOld = commaOrSpace > 0 ? commaOrSpace : spaceAfterOld;
        if (endOld < 0) throw new InvalidOperationException($"Invalid hunk header: {header}");

        string startOldStr = header[(minus + 1)..endOld];
        int countOld = 1;
        if (commaOrSpace > 0)
        {
            int endCount = header.IndexOf(' ', commaOrSpace);
            if (endCount < 0) endCount = plus;
            string countStr = header[(commaOrSpace + 1)..endCount];
            if (!string.IsNullOrWhiteSpace(countStr)) countOld = int.Parse(countStr);
        }

        int startOld = int.Parse(startOldStr);
        return (startOld, countOld);
    }

    private static void EnsureLineEquals(string[] originalLines, int index, string expected)
    {
        if (index >= originalLines.Length)
        {
            throw new InvalidOperationException("Patch failed: original is shorter than expected");
        }

        string actual = originalLines[index];
        if (!string.Equals(actual, expected, StringComparison.Ordinal))
        {
            throw new InvalidOperationException($"Patch failed at line {index + 1}: expected '{expected}', got '{actual}'");
        }
    }

    private static string[] SplitLinesPreserveNoNewline(string text)
    {
        if (string.IsNullOrEmpty(text)) return [string.Empty];
        return text.Replace("\r\n", "\n").Split('\n');
    }
}
